# Current layout:
#
# l l l l u u u u m m m ....
# |       |       |
# |       used    |
# 32-bit size     user memory

# Internally we work with a pointer to the header, and consider block sizes
# to include the header. Pointers are shifted to point to user memory at the
# interface.
# (User) pointers are guaranteed to be 8-byte aligned, as long as all
# allocations are a multiple of 8 bytes.

pageSize = Int32(64*1024) # 64 KiB
headerSize = Int32(8)

fn getBlockSize(p: Ptr) { i32load(p) }
fn setBlockSize(p: Ptr, sz: Int32) { i32store(p, sz) }

fn getBlockUsed(p: Ptr) { i32load(p + Int32(4)) }
fn setBlockUsed(p: Ptr, u: Int32) { i32store(p + Int32(4), u) }

# Initialise first block
memoryGrow(Int32(1))
setBlockSize(Ptr(0), pageSize)

fn memorySize() {
  memoryPages() * pageSize
}

fn npages(bytes: Int32) {
  div(bytes + pageSize - Int32(1), pageSize)
}

fn isLastBlock(ptr, size) {
  addr(ptr + size) == memorySize()
}

fn coalesceBlock(ptr, size) {
  if isLastBlock(ptr, size) { return size }
  next = ptr + size
  if getBlockUsed(next) { return size }
  nextSize = getBlockSize(next)
  # nextSize = coalesceBlock(next, nextSize)
  size = size + nextSize
  setBlockSize(ptr, size)
  return size
}

# Find a free block of size >= n, creating it if necessary.
fn findFreeBlock(n: Int32) {
  ptr = Ptr(0)
  size = getBlockSize(ptr)
  while not(isLastBlock(ptr, size)) {
    if (getBlockUsed(ptr) != true) {
      size = coalesceBlock(ptr, size)
      if (size >= n) {
        return [ptr, size]
      }
    }
    ptr = ptr + size
    size = getBlockSize(ptr)
  }
  if getBlockUsed(ptr) {
    ptr = ptr + size
    size = Int32(0)
  }
  if (size < n) {
    needed = n - size
    alloc = npages(needed)
    memoryGrow(alloc)
    size = size + alloc*pageSize
    setBlockSize(ptr, size)
  }
  return [ptr, size]
}

fn trimBlock(ptr, size, newsize) {
  if (size <= (newsize + headerSize)) {
    return size
  }
  setBlockSize(ptr, newsize)
  newptr = ptr + newsize
  setBlockSize(newptr, size-newsize)
  return newsize
}

fn malloc(n: Int32) {
  n = n + headerSize
  ptrsize = findFreeBlock(n)
  ptr = part(ptrsize, 1)
  size = part(ptrsize, 2)
  size = trimBlock(ptr, size, n)
  setBlockUsed(ptr, true)
  return ptr + headerSize
}

fn free(p: Ptr) {
  p = p - headerSize
  setBlockUsed(p, false)
  return
}
