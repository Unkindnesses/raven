# Current layout:
#
# l l l l u u u u m m m ....
# |       |       |
# |       used    |
# 32-bit size     user memory

# Internally we work with a pointer to the header, and consider block sizes
# to include the header. Pointers are shifted to point to user memory at the
# interface.
# (User) pointers are guaranteed to be 8-byte aligned, as long as all
# allocations are a multiple of 8 bytes.

pageSize = Int32(64*1024) # 64 KiB
headerSize = Int32(8)

fn getBlockSize(p: Ptr) { i32load(p) }
fn setBlockSize!(p: Ptr, sz: Int32) { i32store!(p, sz) }

fn getBlockUsed(p: Ptr) { i32load(p + Int32(4)) }
fn setBlockUsed!(p: Ptr, u: Int32) { i32store!(p + Int32(4), u) }

# Initialise first block
memoryGrow!(Int32(1))
setBlockSize!(Ptr(0), pageSize)

fn memorySize() {
  memoryPages() * pageSize
}

fn npages(bytes: Int32) {
  div(bytes + pageSize - Int32(1), pageSize)
}

fn isLastBlock(ptr, size) {
  addr(ptr + size) == memorySize()
}

fn coalesceBlock(ptr, &size) {
  isLastBlock(ptr, size) && return size
  next = ptr + size
  getBlockUsed(next) && return size
  nextSize = getBlockSize(next)
  nextSize = coalesceBlock(next, nextSize)
  size = size + nextSize
  setBlockSize!(ptr, size)
  return size
}

# Find a free block of size >= n, creating it if necessary.
fn findFreeBlock(n: Int32) {
  ptr = Ptr(0)
  size = getBlockSize(ptr)
  while not(isLastBlock(ptr, size)) {
    if not(getBlockUsed(ptr)) {
      coalesceBlock(ptr, &size)
      (size >= n) && return [ptr, size]
    }
    ptr = ptr + size
    size = getBlockSize(ptr)
  }
  if getBlockUsed(ptr) {
    ptr = ptr + size
    size = Int32(0)
  }
  if (size < n) {
    needed = n - size
    alloc = npages(needed)
    memoryGrow!(alloc)
    size = size + alloc*pageSize
    setBlockSize!(ptr, size)
  }
  return [ptr, size]
}

fn trimBlock(ptr, &size, newsize) {
  (size <= (newsize + headerSize)) && return size
  setBlockSize!(ptr, newsize)
  newptr = ptr + newsize
  setBlockSize!(newptr, size-newsize)
  size = newsize
  return size
}

# Public interface

fn malloc!(n: Int32) {
  n = n + headerSize
  ptrsize = findFreeBlock(n)
  ptr = part(ptrsize, 1)
  size = part(ptrsize, 2)
  trimBlock(ptr, &size, n)
  setBlockUsed!(ptr, true)
  return ptr + headerSize
}

fn free!(p: Ptr) {
  p = p - headerSize
  setBlockUsed!(p, false)
  return
}

fn blockSize(p: Ptr) {
  getBlockSize(p - headerSize) - headerSize
}

fn blockCount(p: Ptr) {
  Int64(getBlockUsed(p - headerSize))
}

fn retain!(p: Ptr) {
  p = p - headerSize
  n = getBlockUsed(p)
  setBlockUsed!(p, n+Int32(1))
  return
}

fn release!(p: Ptr) {
  p = p - headerSize
  n = getBlockUsed(p)
  if (n == Int32(0)) {
    panic("Memory management fault")
  }
  # Setting to 0 equates to freeing
  setBlockUsed!(p, n-Int32(1))
}

fn allocationCount() {
  i = 0
  ptr = Ptr(0)
  while true {
    getBlockUsed(ptr) && (i = i + 1)
    size = getBlockSize(ptr)
    isLastBlock(ptr, size) && break
    ptr = ptr + size
  }
  return i
}
