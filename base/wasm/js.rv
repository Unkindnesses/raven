bundle { JSObject(ref: Ref) }

fn JSObject(id: Int32) {
  r = Ref(8)
  i32store!(pointer(r), id)
  return JSObject(r)
}

fn jsref(x) { jsref(tojs(x)) }

fn jsref(JSObject(ref)) { i32load(pointer(ref)) }

fn global() {
  ref = (wasm { call(`jsglobal`): i32 })
  return JSObject(ref)
}

fn property(obj, prop) {
  obj = jsref(obj)
  prop = jsref(prop)
  ref = (wasm { call(`jsproperty`, obj: i32, prop: i32): i32 })
  return JSObject(ref)
}

fn call(obj, meth) {
  obj = jsref(obj)
  meth = jsref(meth)
  ref = (wasm { call(`jscall0`, obj: i32, meth: i32): i32 })
  return JSObject(ref)
}

fn call(obj, meth, x) {
  obj = jsref(obj)
  meth = jsref(meth)
  x = jsref(x)
  ref = (wasm { call(`jscall1`, obj: i32, meth: i32, x: i32): i32 })
  return JSObject(ref)
}

fn equal(a: JSObject, b: JSObject) {
  a = jsref(a)
  b = jsref(b)
  wasm { call(`jseq`, a: i32, b: i32): i32 }
}

fn new(T) {
  Object = property(global(), "Object")
  this = call(Object, "create", property(T, "prototype"))
  call(T, "call", this)
  return this
}

fn tojs(x: Float64) {
  ref = (wasm { call(`jsbox`, x: f64): i32 })
  return JSObject(ref)
}

fn tojs(x: Int64) { tojs(Float64(x)) }
fn tojs(x: Int32) { tojs(Float64(x)) }

fn Float64(x: JSObject) {
  ref = jsref(x)
  wasm { call(`jsunbox`, ref: i32): f64 }
}

fn panic(s: String) {
  ref = jsref(s)
  wasm { call(`panic`, ref: i32): unreachable }
}

fn string(x: Int32) {
  String(call(x, "toString"))
}

fn string(x: Int64) {
  String(call(x, "toString"))
}

fn _print(x: String) {
  process = property(global(), "process")
  stdout = property(process, "stdout")
  call(stdout, "write", x)
  return
}

fn println(x: JSObject) {
  console = property(global(), "console")
  call(console, "log", x)
  return
}
