export { Bits, Bool, Int, Int64, Int32, bits, oftype, typemin, typemax }

fn matchTrait(tag"common.core.Bits", x: pack(tag"common.core.Bits", _)) { Some(x) }

# TODO lower symbols to literals
fn tag"common.core.Bits"[N] { Params(Bits, N) }

fn (a: Bits) == (b: Bits) { Bool(biteq(a, b)) }

# TODO cast
fn matchTrait(Params(tag"common.core.Bits", N), x: Bits) {
  if bitsize(x) == N { Some(x) }
}

bundle Bool(x: Bits[32])

fn Bool(x: Bits) { pack(Bool, bitcast(bits 32, x)) }

fn Bool(x: Bool) { x }

fn bits(Bool(x)) { x }

fn Bool(a) & Bool(b) { Bool(bitand(a, b)) }
fn Bool(a) | Bool(b) { Bool(bitor(a, b)) }

fn not(Bool(x)) { Bool(biteqz(x)) }

# TODO `bundle Int[N](x: Bits[N])`
bundle Int(x: Bits)

fn tag"common.Int"[N] { Params(Int, N) }

fn matchTrait(Params(tag"common.Int", N), Int(b)) {
  matchTrait(Bits[N], b)
}

fn bits(Int(x)) { x }

fn oftype(to: Int, from: Bits) { Int(bitcast(bits(to), from)) }
fn oftype(to: Int, from: Int) { Int(bitcast_s(bits(to), bits(from))) }

fn oftype(to: Int, from: Bool) { oftype(to, bits(from)) }

# Simple versions that doesn't get overloaded; to bootstrap matching
fn add(a: Int, b: Int) { Int(bitadd(bits(a), bits(b))) }
fn sub(a: Int, b: Int) { Int(bitsub(bits(a), bits(b))) }
fn eq(a: Int, b: Int) { Bool(biteq(bits(a), bits(b))) }
fn lt(a: Int, b: Int) { Bool(bitlt_s(bits(a), bits(b))) }

fn larger(a: Int, b: Int) {
  if lt(bitsize(bits(a)), bitsize(bits(b))) { b } else { a }
}

fn promote(a: Int, b: Int) {
  T = larger(a, b)
  [oftype(T, a), oftype(T, b)]
}

fn intop(f, a: Int, b: Int) {
  [a, b] = promote(a, b)
  f(bits(a), bits(b))
}

fn (a: Int) + (b: Int) { Int(intop(bitadd, a, b)) }
fn (a: Int) - (b: Int) { Int(intop(bitsub, a, b)) }
fn (a: Int) * (b: Int) { Int(intop(bitmul, a, b)) }

fn div(a: Int, b: Int) { Int(intop(bitdiv_s, a, b)) }
fn rem(a: Int, b: Int) { Int(intop(bitrem_s, a, b)) }

fn (a: Int) == (b: Int) { Bool(intop(biteq, a, b)) }
fn (a: Int) != (b: Int) { Bool(intop(bitne, a, b)) }

fn (a: Int) >  (b: Int) { Bool(intop(bitgt_s, a, b)) }
fn (a: Int) >= (b: Int) { Bool(intop(bitge_s, a, b)) }
fn (a: Int) <  (b: Int) { Bool(intop(bitlt_s, a, b)) }
fn (a: Int) <= (b: Int) { Bool(intop(bitle_s, a, b)) }

fn iszero(x: Int) { Bool(biteqz(bits(x))) }

fn zero(x: Int) { oftype(x, 0) }
fn one(x: Int) { oftype(x, 1) }

fn typemin(n: Int) {
  bs = bits(one(n))
  Int(bitshl(bs, bitcast(bs, bits(bitsize(bs)-1))))
}

fn typemax(n: Int) {
  typemin(n)-one(n)
}

fn Bool(x: Int) { not(iszero(x)) }

extend fn Float64(Int(x)) {
  x = bitcast_s(bits 64, x)
  wasm { f64.convert_i64_s(x: i64): f64 }
}

fn (a: Int) / (b: Int) { Float64(a) / Float64(b) }

fn js(x: Int) { js(Float64(x)) }

fn print(x: Int) { print(js(x)) }

fn show(x: Int) {
  N = bitsize(bits(x))
  x = oftype(int 64, x)
  print("oftype(int ")
  print(N)
  print(", ")
  print(x)
  print(")")
}

# Special sizes

fn matchTrait(tag".Int32", x: Int[32]) { Some(x) }
fn matchTrait(tag".Int64", x: Int[64]) { Some(x) }

fn Int32(x) { oftype(int 32, x) }
fn Int64(x) { oftype(int 64, x) }

fn show(x: Int32) {
  print("Int32(")
  print(x)
  print(")")
}

fn show(x: Int64) { print(x) }
