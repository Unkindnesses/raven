export { Bits, Bool, true, false, Int, Int64, Int32, UInt, UInt64, UInt32, UInt16, UInt8, bits, oftype, typemin, typemax, bitsize }

fn matchTrait(tag"common.core.Bits", x: pack(tag"common.core.Bits", _)) { Some(x) }

# TODO lower symbols to literals
fn tag"common.core.Bits"[N] { Params(Bits, N) }

fn (a: Bits) == (b: Bits) { Bool(biteq(a, b)) }

# TODO cast
fn matchTrait(Params(tag"common.core.Bits", N), x: Bits) {
  if bitsize(x) == N { Some(x) }
}

# Bool

bundle Bool(x: Bits[1])

fn Bool(x: Bits) { pack(Bool, bitcast(bits 1, x)) }

fn Bool(x: Bool) { x }

fn bits(Bool(x)) { x }

fn Bool(a) & Bool(b) { Bool(bitand(a, b)) }
fn Bool(a) | Bool(b) { Bool(bitor(a, b)) }

fn not(Bool(x)) { Bool(biteqz(x)) }

fn show(x: Bool) {
  print(if x { "true" } else { "false" })
}

true  = Bool(bits"1")
false = Bool(bits"0")

fn condition(x) { abort("Non-boolean used as a condition") }
fn condition(x: Bool) { x }

# Int

# TODO `bundle Int[N](x: Bits[N])`
bundle Int(x: Bits)

fn tag"common.Int"[N] { Params(Int, N) }

fn matchTrait(Params(tag"common.Int", N), Int(b)) {
  if isa?(b, Bits[N]) {
    Some(Int(b))
  }
}

fn bits(Int(x)) { x }

@extend
fn bitsize(Int(x)) { bitsize(x) }

fn oftype(to: Int, from: Bits) { Int(bitcast(bits(to), from)) }
fn oftype(to: Int, from: Int) { Int(bitcast_s(bits(to), bits(from))) }

fn oftype(to: Int, from: Bool) { oftype(to, bits(from)) }

# Simple versions that doesn't get overloaded; to bootstrap matching
fn add(a: Int, b: Int) { Int(bitadd(bits(a), bits(b))) }
fn sub(a: Int, b: Int) { Int(bitsub(bits(a), bits(b))) }
fn eq(a: Int, b: Int) { Bool(biteq(bits(a), bits(b))) }
fn lt(a: Int, b: Int) { Bool(bitlt_s(bits(a), bits(b))) }

fn larger(a: Int, b: Int) {
  if lt(bitsize(a), bitsize(b)) { b } else { a }
}

fn promote(a: Int, b: Int) {
  T = larger(a, b)
  [oftype(T, a), oftype(T, b)]
}

fn intop(f, a, b) {
  [a, b] = promote(a, b)
  f(bits(a), bits(b))
}

fn (a: Int) + (b: Int) { Int(intop(bitadd, a, b)) }
fn (a: Int) - (b: Int) { Int(intop(bitsub, a, b)) }
fn (a: Int) * (b: Int) { Int(intop(bitmul, a, b)) }

fn div(a: Int, b: Int) { Int(intop(bitdiv_s, a, b)) }
fn rem(a: Int, b: Int) { Int(intop(bitrem_s, a, b)) }

fn (a: Int) == (b: Int) { Bool(intop(biteq, a, b)) }
fn (a: Int) != (b: Int) { Bool(intop(bitne, a, b)) }

fn (a: Int) >  (b: Int) { Bool(intop(bitgt_s, a, b)) }
fn (a: Int) >= (b: Int) { Bool(intop(bitge_s, a, b)) }
fn (a: Int) <  (b: Int) { Bool(intop(bitlt_s, a, b)) }
fn (a: Int) <= (b: Int) { Bool(intop(bitle_s, a, b)) }

fn zero?(x: Int) { Bool(biteqz(bits(x))) }

fn zero(x: Int) { oftype(x, 0) }
fn one(x: Int) { oftype(x, 1) }

fn typemin(n: Int) {
  bs = bits(one(n))
  Int(bitshl(bs, bitcast(bs, bits(bitsize(bs)-1))))
}

fn typemax(n: Int) {
  typemin(n)-one(n)
}

fn Bool(x: Int) { not(zero?(x)) }

@extend
fn Float64(Int(x)) {
  x = bitcast_s(bits 64, x)
  wasm f64.convert_i64_s(x: i64): f64
}

fn (a: Int) / (b: Int) { Float64(a) / Float64(b) }

fn js(x: Int) { js(Float64(x)) }

fn string(x: Int, base: Int) { String(js(x).toString(base)) }
fn string(x: Int) { string(x, 10) }

fn print(x: Int) { print(js(x)) }

fn show(x: Int) {
  N = bitsize(bits(x))
  print("oftype(int ")
  print(N)
  print(", ")
  print(x)
  print(")")
}

# Special sizes

fn matchTrait(tag".Int32", x: Int[32]) { Some(x) }
fn matchTrait(tag".Int64", x: Int[64]) { Some(x) }

fn Int32(x) { oftype(int 32, x) }
fn Int64(x) { oftype(int 64, x) }

fn show(x: Int32) {
  print("Int32(")
  print(x)
  print(")")
}

fn show(x: Int64) { print(x) }

# UInt

bundle UInt(x: Bits)

fn tag"common.UInt"[N] { Params(UInt, N) }

fn matchTrait(Params(tag"common.UInt", N), UInt(b)) {
  if isa?(b, Bits[N]) {
    Some(UInt(b))
  }
}

fn bits(UInt(x)) { x }

@extend
fn bitsize(UInt(x)) { bitsize(x) }

fn UInt(x: Int) { UInt(bits(x)) } # TODO check positive

fn oftype(to: UInt, from: Bits) { UInt(bitcast(bits(to), from)) }
fn oftype(to: UInt, from: UInt) { UInt(bitcast(bits(to), bits(from))) }

fn oftype(to: UInt, from: Bool) { oftype(to, bits(from)) }
fn oftype(to: UInt, from: Int) { oftype(to, UInt(from)) }

fn oftype(to: Int, from: UInt) { oftype(to, bits(from)) } # TODO check positive

fn larger(a: UInt, b: UInt) {
  if lt(bitsize(a), bitsize(b)) { b } else { a }
}

fn promote(a: UInt, b: UInt) {
  T = larger(a, b)
  [oftype(T, a), oftype(T, b)]
}

fn (a: UInt) + (b: UInt) { UInt(intop(bitadd, a, b)) }
fn (a: UInt) - (b: UInt) { UInt(intop(bitsub, a, b)) }
fn (a: UInt) * (b: UInt) { UInt(intop(bitmul, a, b)) }

fn div(a: UInt, b: UInt) { UInt(intop(bitdiv_u, a, b)) }
fn rem(a: UInt, b: UInt) { Int(intop(bitrem_u, a, b)) }

fn (a: UInt) | (b: UInt) { UInt(intop(bitor, a, b)) }
fn (a: UInt) & (b: UInt) { UInt(intop(bitand, a, b)) }

fn (a: UInt) == (b: UInt) { Bool(intop(biteq, a, b)) }
fn (a: UInt) != (b: UInt) { Bool(intop(bitne, a, b)) }

fn (a: UInt) >  (b: UInt) { Bool(intop(bitgt_u, a, b)) }
fn (a: UInt) >= (b: UInt) { Bool(intop(bitge_u, a, b)) }
fn (a: UInt) <  (b: UInt) { Bool(intop(bitlt_u, a, b)) }
fn (a: UInt) <= (b: UInt) { Bool(intop(bitle_u, a, b)) }

fn zero?(x: UInt) { Bool(biteqz(bits(x))) }

fn zero(x: UInt) { oftype(x, 0) }
fn one(x: UInt) { oftype(x, 1) }

fn typemin(n: UInt) { zero(n) }
fn typemax(n: UInt) { typemin(n)-one(n) }

fn Bool(x: UInt) { not(zero?(x)) }

@extend
fn Float64(UInt(x)) {
  x = bitcast(bits 64, x)
  wasm f64.convert_i64_u(x: i64): f64
}

fn (a: UInt) / (b: UInt) { Float64(a) / Float64(b) }

fn js(x: UInt) { js(Float64(x)) }

fn print(x: UInt) { print(js(x)) }

fn show(x: UInt) {
  N = bitsize(bits(x))
  print("oftype(uint ")
  print(N)
  print(", 0x")
  print(string(Int64(x), 16))
  print(")")
}

# Special sizes

fn matchTrait(tag".UInt8", x: UInt[8]) { Some(x) }
fn matchTrait(tag".UInt16", x: UInt[16]) { Some(x) }
fn matchTrait(tag".UInt32", x: UInt[32]) { Some(x) }
fn matchTrait(tag".UInt64", x: UInt[64]) { Some(x) }

fn UInt8(x) { oftype(uint 8, x) }
fn UInt16(x) { oftype(uint 16, x) }
fn UInt32(x) { oftype(uint 32, x) }
fn UInt64(x) { oftype(uint 64, x) }

fn show(x: UInt8) {
  print("0x")
  print(js(string(Int64(x), 16)).padStart(2, "0"))
}

fn show(x: UInt16) {
  print("0x")
  print(js(string(Int64(x), 16)).padStart(4, "0"))
}

fn show(x: UInt32) {
  print("0x")
  print(js(string(Int64(x), 16)).padStart(8, "0"))
}

fn show(x: UInt64) {
  print("0x")
  print(js(string(Int64(x), 16)).padStart(16, "0"))
}
