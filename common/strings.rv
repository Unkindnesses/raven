export { Char, String, Regex, string, concat, compare, utf16, contains?, matches }

# Chars

bundle Char(val: UInt[21])

fn Char(x: Int | UInt) { Char(oftype(uint 21, x)) }

fn Char(x: UInt[21]) { pack(Char, x) }

fn string(Char(val)) {
  ref = wasm call("wasm:js-string".fromCodePoint, widen(bits(val)): i32): ref!
  return unsafeString(ref)
}

fn print(ch: Char) { print(string(ch)) }

fn show(ch: Char) {
  print(`c`)
  show(string(ch))
}

# Strings

bundle String(ref: Ref)

fn unsafeString(ref: Ref) { pack(String, ref) }

fn String(ref: Ref) {
  ref = wasm call("wasm:js-string".cast, ref: ref): ref!
  ref = jsref(JSObject(ref).toWellFormed())
  return unsafeString(ref)
}

fn String(obj: JSObject) { String(jsref(obj)) }

fn js(String(r)) { JSObject(r) }

fn show(x: String) {
  print(js().JSON.stringify(x))
}

fn iterator(x: String) {
  mapping(String, js(x))
}

fn length(s: String) { count(s) }

fn concat(String(a), String(b)) {
  ref = wasm call("wasm:js-string".concat, a: ref, b: ref): ref!
  return unsafeString(ref)
}

fn String(a) == String(b) {
  r = wasm call("wasm:js-string".equals, a: ref, b: ref): i32
  return Bool(r)
}

fn compare(String(a), String(b)) {
  r = wasm call("wasm:js-string".compare, a: ref, b: ref): i32
  return Int64(Int32(r))
}

# Data views

bundle UTF16View(s: String)

fn utf16(s: String) { UTF16View(s) }

fn length(UTF16View(s)) {
  String(x) = s # TODO fix nested constructor pattern
  len = wasm call("wasm:js-string".length, x: ref): i32
  return Int64(len)
}

fn UTF16View(s)[i] {
  String(x) = s
  i = widen(bits(Int32(i-1))) # TODO remove widen
  ch = wasm call("wasm:js-string".charCodeAt, x: ref, i: i32): i32
  return UInt16(ch)
}

# Tags

fn string(x: Tag) { tagstring(x) }

fn (a: Tag) == (b: Tag) { shortcutEquals(a, b) }

fn show(x: Tag) {
  print(`tag"`)
  print(string(x))
  print(`"`)
}

# Regex

bundle Regex(r: JSObject)

# TODO flags
fn Regex(r: String) { Regex(js().RegExp(r, "vg")) }

fn js(Regex(r)) { r }

fn show(Regex(r)) {
  print("r`")
  print(r.source)
  print("`")
}

fn contains?(s: String, Regex(r)) {
  r["lastIndex"] = 0 # JS RegExps have state!
  return Bool(r.test(s))
}

bundle Matches(s: String, r: Regex)

fn matches(s: String, r: Regex) { Matches(s, r) }

# TODO lambdas
fn collectStrings(xs) { map(String, xs) }

fn iterator(Matches(s, r)) {
  mapping(collectStrings, js(s).matchAll(r))
}
