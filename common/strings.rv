export { Char, String, Regex, string, concat, compare, chars, utf8, utf16, contains?, matches }

# Chars

bundle Char(val: UInt[21])

fn Char(x: Int | UInt) { Char(oftype(uint 21, x)) }

fn Char(x: UInt[21]) { pack(Char, x) }

fn UInt32(Char(x)) { UInt32(x) }

fn string(Char(val)) {
  ref = wasm call("wasm:js-string".fromCodePoint, widen(bits(val)): i32): ref!
  return unsafeString(ref)
}

fn print(ch: Char) { print(string(ch)) }

fn show(ch: Char) {
  print(`c`)
  show(string(ch))
}

# Strings

bundle String(ref: Ref)

fn unsafeString(ref: Ref) { pack(String, ref) }

fn String(ref: Ref) {
  ref = wasm call("wasm:js-string".cast, ref): ref!
  ref = jsref(JSObject(ref).toWellFormed())
  return unsafeString(ref)
}

fn String(obj: JSObject) { String(jsref(obj)) }

fn js(String(r)) { JSObject(r) }
fn jsref(String(r)) { r }

fn show(x: String) {
  print(String(js.JSON.stringify(x)))
}

bundle StringItr(s: String, i: Int64)

fn iterate(x: String) { StringItr(x, 0) }

fn next(&itr: StringItr(s, i)) {
  if i >= length(utf16(s)) { return }
  idx = widen(bits(Int32(i)))
  cp = UInt32(wasm call("wasm:js-string".codePointAt, jsref(s), idx: i32): i32)
  ch = Char(cp)
  itr = StringItr(s, if cp >= 0x10000 { i + 2 } else { i + 1 })
  return Some(ch)
}

fn length(s: String) { count(s) }

fn (s: String)[i] { nth(s, i) }

fn concat(a: String, b: String) {
  ref = wasm call("wasm:js-string".concat, jsref(a), jsref(b)): ref!
  return unsafeString(ref)
}

fn (a: String) == (b: String) {
  r = wasm call("wasm:js-string".equals, jsref(a), jsref(b)): i32
  return Bool(r)
}

fn compare(a: String, b: String) {
  r = wasm call("wasm:js-string".compare, jsref(a), jsref(b)): i32
  return Int64(Int32(r))
}

# Data views

bundle Chars(data: List)

fn chars(s: String) { Chars(collect(s)) }

fn Chars(data)[i] { data[i] }
fn length(Chars(data)) { length(data) }
fn iterate(Chars(data)) { iterate(data) }

bundle UTF8View(data: List)

fn utf8(s: String) {
  bytes = []
  for ch = s {
    ch = UInt32(ch)
    if ch <= 0x007F {
      append(&bytes, UInt8(ch))
    } else if ch <= 0x07FF {
      append(&bytes, UInt8(0x00C0 | div(ch, 0x0040)))
      append(&bytes, UInt8(0x0080 | (ch & 0x003F)))
    } else if ch <= 0xFFFF {
      append(&bytes, UInt8(0x00E0 | div(ch, 0x1000)))
      append(&bytes, UInt8(0x0080 | (div(ch, 0x0040) & 0x003F)))
      append(&bytes, UInt8(0x0080 | (ch & 0x003F)))
    } else {
      append(&bytes, UInt8(0x00F0 | div(ch, 0x40000)))
      append(&bytes, UInt8(0x0080 | (div(ch, 0x1000) & 0x003F)))
      append(&bytes, UInt8(0x0080 | (div(ch, 0x0040) & 0x003F)))
      append(&bytes, UInt8(0x0080 | (ch & 0x003F)))
    }
  }
  return UTF8View(bytes)
}

fn UTF8View(data)[i] { data[i] }
fn length(UTF8View(data)) { length(data) }
fn iterate(UTF8View(data)) { iterate(data) }

bundle UTF16View(s: String)

fn utf16(s: String) { UTF16View(s) }

fn length(UTF16View(s)) {
  len = wasm call("wasm:js-string".length, jsref(s)): i32
  return Int64(len)
}

fn UTF16View(s)[i] {
  i = widen(bits(Int32(i-1))) # TODO remove widen
  ch = wasm call("wasm:js-string".charCodeAt, jsref(s), i: i32): i32
  return UInt16(ch)
}

fn iterate(v: UTF16View) { IndexIterator(v) }

# Tags

fn string(x: Tag) { tagstring(x) }

fn (a: Tag) == (b: Tag) { shortcutEquals(a, b) }

fn show(x: Tag) {
  print(`tag"`)
  print(string(x))
  print(`"`)
}

# Regex

bundle Regex(r: JSObject)

# TODO flags
fn Regex(r: String) { Regex(js.RegExp(r, "vg")) }

fn js(Regex(r)) { r }

fn show(Regex(r)) {
  print("r`")
  print(r.source)
  print("`")
}

fn contains?(s: String, Regex(r)) {
  r["lastIndex"] = 0 # JS RegExps have state!
  return Bool(r.test(s))
}

bundle Matches(s: String, r: Regex)

fn matches(s: String, r: Regex) { Matches(s, r) }

# TODO lambdas
fn collectStrings(xs) { map(String, xs) }

fn iterate(Matches(s, r)) {
  mapping(collectStrings, js(s).matchAll(r))
}
