export { Ptr, Function, Ref, addr, pointer, invoke }

bundle { Ptr(x: Int32) }

fn Ptr(x: Int64) { Ptr(Int32(x)) }

fn addr(Ptr(x)) { x }

fn print(x: Ptr) {
  print("Ptr@")
  print(addr(x))
}

fn (p: Ptr) + x {
  Ptr(addr(p) + Int32(x))
}

fn (p: Ptr) - x {
  Ptr(addr(p) - Int32(x))
}

fn (p: Ptr) == (q: Ptr) {
  addr(p) == addr(q)
}

fn memoryPages() {
  wasm { memory.size(): i32 }
}

fn memoryGrow!(n: Int32) {
  wasm { memory.grow(n: i32): i32 }
}

fn i32load(p: Ptr) {
  a = addr(p)
  wasm { i32.load(a: i32): i32 }
}

fn i32store!(p: Ptr, x: Int32) {
  a = addr(p)
  wasm { i32.store(a: i32, x: i32) }
}

# Function pointer

TPtr = Pack(Literal(tag".Ptr"), Int32)
TNil = Pack(Literal(tag".Nil"))

fn Function(f, I, O) {
  ptr = function(f, I, O)
  Function(ptr, I, O)
}

bundle { Function(f: Int32, I, O) }

extend fn invoke(f: Function, xs...) {
  Function(f, I, O) = f
  invoke(f, I, O, xs...)
}

# Managed pointer

fn hold(x...) { nil }

bundle { Ref(p: Ptr) }

fn Ref(n: Int64) {
  ptr = malloc!(Int32(n+8))
  i32store!(ptr, Int32(-1))
  return Ref(ptr)
}

fn pointer(Ref(ptr)) { ptr+8 }

fn cleanup!(r: Ref(ptr), func) {
  f = function(func, [TPtr], TNil)
  i32store!(ptr, f)
  hold(r) # retain r until cleanup is set
  return
}
