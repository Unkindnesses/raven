export { JSObject, abort, global, call, errcall, await, tojs, sleep, readline }

fn jsfree(ptr: Ptr) {
  id = i32load(ptr)
  wasm { call(support.release, id: i32) }
  return
}

bundle JSObject(ref: Ref)

fn JSObject(id: Int32) {
  if jsalloc() {
    r = Ref(8)
    i32store!(pointer(r), id)
    cleanup!(r, jsfree)
    return JSObject(r)
  } else {
    return pack(tag".JSObject", id)
  }
}

fn tojs(x: JSObject) { x }

fn jsref(x) { jsref(tojs(x)) }

fn jsref(JSObject(ref: Ref)) { i32load(pointer(ref)) }

# We have a compiler option which skips the `Ref` wrapper, which lets us avoid
# compiling malloc. (And of course JS objects won't be freed.)
fn jsref(JSObject(ref: Int32)) { ref }

fn retain!(JSObject(ref: Ref)) { retain!(ref) }

fn retain!(JSObject(_: Int32)) {}

fn global() {
  ref = wasm { call(support.global): i32 }
  return JSObject(ref)
}

fn property(obj, prop) { property(tojs(obj), tojs(prop)) }

fn property(obj: JSObject, prop: JSObject) {
  ref = wasm { call(support.property, jsref(obj): i32, jsref(prop): i32): i32 }
  hold(obj, prop)
  return JSObject(ref)
}

fn call(obj, meth) { call(tojs(obj), tojs(meth)) }

fn call(obj: JSObject, meth: JSObject) {
  ref = wasm { call(support.call, jsref(obj): i32, jsref(meth): i32): i32 }
  hold(obj, meth)
  return JSObject(ref)
}

fn call(obj, meth, x) { call(tojs(obj), tojs(meth), tojs(x)) }

fn call(obj: JSObject, meth: JSObject, x: JSObject) {
  ref = wasm { call(support.call, jsref(obj): i32, jsref(meth): i32, jsref(x): i32): i32 }
  hold(obj, meth, x)
  return JSObject(ref)
}

fn errcall(obj, meth) { errcall(tojs(obj), tojs(meth)) }

fn errcall(obj: JSObject, meth: JSObject) {
  [err, ref] = wasm { call(support.errcall, jsref(obj): i32, jsref(meth): i32): (i32, i32) }
  hold(obj, meth)
  result = JSObject(ref)
  if err {
    return Err(result)
  } else {
    return Ok(result)
  }
}

fn errcall(obj, meth, x) { errcall(tojs(obj), tojs(meth), tojs(x)) }

fn errcall(obj: JSObject, meth: JSObject, x: JSObject) {
  [err, ref] = wasm { call(support.errcall, jsref(obj): i32, jsref(meth): i32, jsref(x): i32): (i32, i32) }
  hold(obj, meth, x)
  result = JSObject(ref)
  if err {
    return Err(result)
  } else {
    return Ok(result)
  }
}

fn await(obj: JSObject) {
  ref = wasm { call(support.await, jsref(obj): i32): i32 }
  hold(obj)
  return JSObject(ref)
}

fn equal(a: JSObject, b: JSObject) {
  result = wasm { call(support.equal, jsref(a): i32, jsref(b): i32): i32 }
  hold(a, b)
  return result
}

fn new(T: JSObject) {
  Object = property(global(), "Object")
  this = call(Object, "create", property(T, "prototype"))
  call(T, "call", this)
  return this
}

fn tojs(x: Float64) {
  ref = wasm { call(support.createRef, x: f64): i32 }
  return JSObject(ref)
}

fn tojs(x: Int64) { tojs(Float64(x)) }
fn tojs(x: Int32) { tojs(Float64(x)) }

extend fn Float64(obj: JSObject) {
  x = wasm { call(support.fromRef, jsref(obj): i32): f64 }
  hold(obj)
  return x
}

fn abort(s: JSObject) {
  retain!(s)
  wasm { call(support.abort, jsref(s): i32): unreachable }
}

fn abort(s: JSObject, cause: JSObject) {
  retain!(s)
  retain!(cause)
  wasm { call(support.abort, jsref(s): i32, jsref(cause): i32): unreachable }
}

fn abort(s: String) { abort(tojs(s)) }
fn abort(s: String, cause) { abort(tojs(s), tojs(cause)) }

fn string(x: JSObject) {
  String(call(x, "toString"))
}

fn string(x: (Int32 | Int64 | Float32 | Float64)) {
  String(call(x, "toString"))
}

fn print(x: String) {
  process = property(global(), "process")
  stdout = property(process, "stdout")
  call(stdout, "write", tojs(x))
  return
}

fn show(x: JSObject) {
  print(string(x))
}

fn println(x: JSObject) {
  console = property(global(), "console")
  call(console, "log", x)
  return
}

fn sleep(n) {
  await(call(global(), "sleep", n))
  return
}

fn readline() {
  return String(await(call(global(), "readline")))
}
