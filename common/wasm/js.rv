export {
  JSObject, debugger, abort, js, property, call, errcall, await, new, sleep
  readline, require
}

CoreRef = tag"common.core.Ref"
fn matchTrait(tag"common.core.Ref", x: pack(tag"common.core.Ref", _)) { Some(x) }

fn jsfree(ptr: Ptr) {
  id = i32load(ptr)
  wasm { call(support.release, bits(id): i32) }
  return
}

bundle JSObject(ref: CoreRef | Ref)

fn JSObject(id: Int32) {
  if jsalloc() {
    r = Ref(8)
    i32store!(pointer(r), id)
    cleanup!(r, jsfree)
    return JSObject(r)
  } else {
    return pack(tag".JSObject", id)
  }
}

fn JSObject(id: Bits) { JSObject(Int32(id)) }

fn js(x: JSObject) { x }

fn jsref(JSObject(ref: CoreRef)) { ref }

fn jsref(JSObject(ref: Ref)) { bits(i32load(pointer(ref))) }

# We have a compiler option which skips the `Ref` wrapper, which lets us avoid
# compiling malloc. (And of course JS objects won't be freed.)
fn jsref(JSObject(ref: Int32)) { bits(ref) }

fn retain!(JSObject(_)) {}
fn retain!(JSObject(ref: Ref)) { retain!(ref) }

fn js() {
  ref = wasm { call(support.global): ref }
  return JSObject(ref)
}

fn (obj: JSObject)[prop] { obj[js(prop)] }

fn (obj: JSObject)[prop: JSObject] {
  ref = wasm { call(support.property, jsref(obj): ref, jsref(prop): ref): ref }
  hold(obj, prop)
  return JSObject(ref)
}

fn field(obj: JSObject, f: Tag) { obj[string(f)] }

fn call(obj: JSObject, meth, args...) { apply(obj, js(meth), js(args)) }

fn apply(obj: JSObject, meth: JSObject, args: JSObject) {
  ref = wasm { call(support.apply, jsref(obj): ref, jsref(meth): ref, jsref(args): ref): ref }
  hold(obj, meth, args)
  return JSObject(ref)
}

fn call(obj: JSObject, meth) { call(obj, js(meth)) }

fn call(obj: JSObject, meth: JSObject) {
  ref = wasm { call(support.call, jsref(obj): ref, jsref(meth): ref): ref }
  hold(obj, meth)
  return JSObject(ref)
}

fn call(obj: JSObject, meth, x) { call(obj, js(meth), js(x)) }

fn call(obj: JSObject, meth: JSObject, x: JSObject) {
  ref = wasm { call(support.call, jsref(obj): ref, jsref(meth): ref, jsref(x): ref): ref }
  hold(obj, meth, x)
  return JSObject(ref)
}

fn method(obj: JSObject, meth: Tag, args...) {
  call(obj, string(meth), args...)
}

fn errcall(obj: JSObject, meth) { errcall(obj, js(meth)) }

fn errcall(obj: JSObject, meth: JSObject) {
  [err, ref] = wasm { call(support.errcall, jsref(obj): ref, jsref(meth): ref): (i32, ref) }
  hold(obj, meth)
  result = JSObject(ref)
  if Bool(err) {
    return Err(result)
  } else {
    return Ok(result)
  }
}

fn errcall(obj: JSObject, meth, x) { errcall(obj, js(meth), js(x)) }

fn errcall(obj: JSObject, meth: JSObject, x: JSObject) {
  [err, ref] = wasm { call(support.errcall, jsref(obj): ref, jsref(meth): ref, jsref(x): ref): (i32, ref) }
  hold(obj, meth, x)
  result = JSObject(ref)
  if Bool(err) {
    return Err(result)
  } else {
    return Ok(result)
  }
}

fn await(obj: JSObject) {
  ref = wasm { call(support.await, jsref(obj): ref): ref }
  hold(obj)
  return JSObject(ref)
}

fn (a: JSObject) == (b: JSObject) {
  result = wasm { call(support.equal, jsref(a): ref, jsref(b): ref): i32 }
  hold(a, b)
  return Bool(result)
}

fn new(T: JSObject, args...) {
  js().Reflect.construct(T, args)
}

fn js(x: Float64) {
  ref = wasm { call(support.identity, x: f64): ref }
  return JSObject(ref)
}

fn js(x: Float32) { js(Float64(x)) }

@extend
fn Float64(obj: JSObject) {
  x = wasm { call(support.identity, jsref(obj): ref): f64 }
  hold(obj)
  return x
}

@extend
fn Int32(obj: JSObject) {
  x = wasm { call(support.identity, jsref(obj): ref): i32 }
  hold(obj)
  return Int32(x)
}

fn Bool(obj: JSObject) { Bool(Int32(obj)) }

fn condition(obj: JSObject) { condition(Bool(obj)) }
fn not(obj: JSObject) { not(Bool(obj)) }

fn debugger() {
  wasm { call(support.debugger) }
}

fn abort(s: JSObject) {
  retain!(s)
  wasm { call(support.abort, jsref(s): ref): unreachable }
}

fn abort(s: JSObject, cause: JSObject) {
  retain!(s)
  retain!(cause)
  wasm { call(support.abort, jsref(s): ref, jsref(cause): ref): unreachable }
}

fn abort(s: String) { abort(js(s)) }
fn abort(s: String, cause) { abort(js(s), js(cause)) }

fn string(x: JSObject) {
  String(x.toString())
}

fn string(x: (Float32 | Float64)) {
  string(js(x))
}

fn print(x: String) {
  js().process.stdout.write(x)
  return
}

fn show(x: JSObject) {
  print(string(x))
}

fn println(x: JSObject) {
  js().console.log(x)
  return
}

fn replshow(x: JSObject) {
  println(x)
}

fn iterator(x: JSObject) {
  x[js().Symbol.iterator].call(x)
}

fn next(&x: JSObject) {
  val = x.next()
  if not(val.done) { Some(val.value) }
}

fn require(s) {
  return js().require(s)
}

fn sleep(n) {
  await(js().sleep(n))
  return
}

fn readline() {
  return String(await(js().readline()))
}
