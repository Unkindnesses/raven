export {
  JSObject, debugger, abort, js, call, errcall, await, new, sleep
  readline, import, typeof
}

fn matchTrait(tag"common.core.Ref", x: pack(tag"common.core.Ref", _)) { Some(x) }

fn show(x: Ref) { print("Ref(...)") }

bundle JSObject(ref: Ref)

fn JSObject() { new(js.Object) }

fn js(x: JSObject) { x }

fn jsref(x) { jsref(js(x)) }
fn jsref(JSObject(ref)) { ref }

fn js() {
  js`return globalThis`
}

fn (obj: JSObject)[prop] { obj[js(prop)] }

fn (obj: JSObject)[prop: JSObject] {
  js`return \obj[\prop]`
}

fn set(&obj: JSObject, x, prop) { obj[js(prop)] = js(x) }

fn set(&obj: JSObject, x: JSObject, prop: JSObject) {
  js`\obj[\prop] = \x`
  return obj
}

fn field(tag".js", f: Tag) { field(js(), f) }

fn field(obj: JSObject, f: Tag) { obj[string(f)] }

fn call(obj: JSObject, meth, args...) { apply(obj, js(meth), js(args)) }

fn apply(obj: JSObject, meth: JSObject, args: JSObject) {
  ref = wasm call(support.apply, jsref(obj), jsref(meth), jsref(args)): ref
  return JSObject(ref)
}

fn call(obj: JSObject, meth) { call(obj, js(meth)) }

fn call(obj: JSObject, meth: JSObject) {
  ref = wasm call(support.call, jsref(obj), jsref(meth)): ref
  return JSObject(ref)
}

fn call(obj: JSObject, meth, x) { call(obj, js(meth), js(x)) }

fn call(obj: JSObject, meth: JSObject, x: JSObject) {
  ref = wasm call(support.call, jsref(obj), jsref(meth), jsref(x)): ref
  return JSObject(ref)
}

fn method(tag".js", meth: Tag, args...) {
  method(js(), meth, args...)
}

fn method(obj: JSObject, meth: Tag, args...) {
  call(obj, string(meth), args...)
}

fn errcall(obj: JSObject, meth) { errcall(obj, js(meth)) }

fn errcall(obj: JSObject, meth: JSObject) {
  [err, ref] = wasm call(support.errcall, jsref(obj), jsref(meth)): (i32, ref)
  result = JSObject(ref)
  if Bool(err) {
    return Err(result)
  } else {
    return Ok(result)
  }
}

fn errcall(obj: JSObject, meth, x) { errcall(obj, js(meth), js(x)) }

fn errcall(obj: JSObject, meth: JSObject, x: JSObject) {
  [err, ref] = wasm call(support.errcall, jsref(obj), jsref(meth), jsref(x)): (i32, ref)
  result = JSObject(ref)
  if Bool(err) {
    return Err(result)
  } else {
    return Ok(result)
  }
}

fn await(obj: JSObject) {
  ref = wasm call(support.await, jsref(obj)): ref
  return JSObject(ref)
}

fn (a: JSObject) == (b: JSObject) {
  result = wasm call(support.equal, jsref(a), jsref(b)): i32
  return Bool(result)
}

fn new(T: JSObject, args...) {
  js.Reflect.construct(T, args)
}

fn js(x: Float64) {
  ref = wasm call(support.identity, x: f64): ref
  return JSObject(ref)
}

fn js(x: Float32) { js(Float64(x)) }

@extend
fn Float64(obj: JSObject) {
  x = wasm call(support.identity, jsref(obj)): f64
  return x
}

@extend
fn Int32(obj: JSObject) {
  x = wasm call(support.identity, jsref(obj)): i32
  return Int32(x)
}

fn oftype(to: Int, from: JSObject) {
  oftype(to, Int32(from))
}

fn oftype(to: UInt, from: JSObject) {
  oftype(to, bits(Int32(from)))
}

fn Bool(obj: JSObject) { Bool(Int32(obj)) }

fn condition(obj: JSObject) { condition(Bool(obj)) }
fn not(obj: JSObject) { not(Bool(obj)) }

fn debugger() {
  wasm call(support.debugger): ref
}

fn abort(s: JSObject) {
  wasm call(support.abort, jsref(s)): unreachable
}

fn abort(s: JSObject, cause: JSObject) {
  wasm call(support.abort, jsref(s), jsref(cause)): unreachable
}

fn abort(s: String) { abort(js(s)) }
fn abort(s: String, cause) { abort(js(s), js(cause)) }

fn typeof(x: JSObject) {
  String(js`return typeof \x`)
}

fn isPrimitive(x: JSObject) {
  ((typeof(x) == "string") || (typeof(x) == "number")) || (typeof(x) == "boolean")
}

fn string(x: JSObject) {
  String(js\`return `${\x}``\)
}

fn string(x: (Float32 | Float64)) {
  string(js(x))
}

fn print(x: String) {
  js.process.stdout.write(x)
  return
}

fn print(x: JSObject) {
  print(string(x))
}

fn show(x: JSObject) {
  if isPrimitive(x) {
    print("js(")
    print(String(js.JSON.stringify(x)))
    print(")")
  } else {
    print(string(x))
  }
}

fn println(x: JSObject) {
  js.console.log(x)
  return
}

fn replshow(x: JSObject) {
  if isPrimitive(x) {
    show(x)
    println()
  } else {
    println(x)
  }
}

fn iterator(x: JSObject) {
  x[js.Symbol.iterator].call(x)
}

fn next(&x: JSObject) {
  val = x.next()
  if not(val.done) { Some(val.value) }
}

fn import(s) {
  return await(js`return import(\s)`)
}

fn sleep(n) {
  p = ```js
  return new Promise(resolve => {
    setTimeout(() => { resolve() }, \n * 1000)
  })
  ```
  await(p)
  return
}
