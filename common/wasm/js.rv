fn jsfree(ptr: Ptr) {
  id = i32load(ptr)
  wasm { call("jsfree", id: i32) }
  return
}

bundle { JSObject(ref: Ref) }

fn JSObject(id: Int32) {
  r = Ref(8)
  i32store!(pointer(r), id)
  cleanup!(r, jsfree)
  return JSObject(r)
}

fn tojs(x: JSObject) { x }

fn jsref(x) { jsref(tojs(x)) }

fn jsref(JSObject(ref)) { i32load(pointer(ref)) }

fn global() {
  ref = wasm { call("jsglobal"): i32 }
  return JSObject(ref)
}

fn property(obj, prop) {
  obj = tojs(obj)
  prop = tojs(prop)
  ref = wasm { call("jsproperty", jsref(obj): i32, jsref(prop): i32): i32 }
  preserve(obj, prop)
  return JSObject(ref)
}

fn call(obj, meth) {
  obj = tojs(obj)
  meth = tojs(meth)
  ref = wasm { call("jscall0", jsref(obj): i32, jsref(meth): i32): i32 }
  preserve(obj, meth)
  return JSObject(ref)
}

fn call(obj, meth, x) {
  obj = tojs(obj)
  meth = tojs(meth)
  x = tojs(x)
  ref = wasm { call("jscall1", jsref(obj): i32, jsref(meth): i32, jsref(x): i32): i32 }
  preserve(obj, meth, x)
  return JSObject(ref)
}

fn await(obj: JSObject) {
  susp = wasm { (global.get)(0): externref }
  ref = wasm { call("jsawait", susp: externref, jsref(obj): i32): i32 }
  preserve(obj)
  return JSObject(ref)
}

fn equal(a: JSObject, b: JSObject) {
  a = tojs(a)
  b = tojs(b)
  result = wasm { call("jseq", jsref(a): i32, jsref(b): i32): i32 }
  preserve(a, b)
  return result
}

fn new(T) {
  Object = property(global(), "Object")
  this = call(Object, "create", property(T, "prototype"))
  call(T, "call", this)
  return this
}

fn tojs(x: Float64) {
  ref = wasm { call("jsbox", x: f64): i32 }
  return JSObject(ref)
}

fn tojs(x: Int64) { tojs(Float64(x)) }
fn tojs(x: Int32) { tojs(Float64(x)) }

extend fn Float64(obj: JSObject) {
  x = wasm { call("jsunbox", jsref(obj): i32): f64 }
  preserve(obj)
  return x
}

fn panic(s: String) {
  ref = jsref(s)
  # TODO preserve s
  wasm { call("panic", ref: i32): unreachable }
}

fn string(x: (Int32 | Int64 | Float32 | Float64)) {
  String(call(x, "toString"))
}

fn _print(x: String) {
  process = property(global(), "process")
  stdout = property(process, "stdout")
  call(stdout, "write", x)
  return
}

fn println(x: JSObject) {
  console = property(global(), "console")
  call(console, "log", x)
  return
}

fn sleep(n) {
  await(call(global(), "sleep", n))
  return
}
