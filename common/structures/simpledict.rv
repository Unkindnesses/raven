# Simple linked list of pairs, for pattern matching. The recursion makes it easy
# to unroll everything.

bundle { Pair(a, b) }

fn print(Pair(a, b)) {
  print(a)
  print(" => ")
  print(b)
}

fn simpledict() { seq() }

fn haskey(d: Empty, k: Tag) { false }
fn haskey(d: Prepend, k: Tag) { (part(first(d), 1) == k) || haskey(rest(d), k) }

fn getkey(d: Empty, k: Tag) {
  panic(concat("No such key: ", string(k)))
}

fn getkey(d: Prepend, k: Tag) {
  p = first(d)
  if part(p, 1) == k {
    return part(p, 2)
  } else {
    return getkey(rest(d), k)
  }
}

fn setkey(&d: Empty, k: Tag, v) {
  d = prepend(d, Pair(k, v))
}

fn setkey(&d: Prepend, k: Tag, v) {
  p = first(d)
  if part(p, 1) == k {
    d = prepend(rest(d), Pair(k, v))
  } else {
    d = prepend(setkey(rest(d), k, v), p)
  }
}

fn merge(&d: Empty, k: Tag, v) {
  d = prepend(d, Pair(k, v))
}

fn merge(&d: Prepend, k: Tag, v) {
  p = first(d)
  if part(p, 1) == k {
    if part(p, 2) == v {
      return d
    } else {
      d = nil
    }
  } else {
    e = merge(rest(d), k, v)
    if isnil(e) {
      d = nil
    } else {
      d = prepend(notnil(e), p)
    }
  }
}

# Returns nil when there is a clash; intended for pattern matching
fn merge(&d, e: Empty) { d }

fn merge(&d, e: Prepend) {
  p = first(e)
  merge(&d, part(p, 1), part(p, 2))
  if isnil(d) { return d = nil }
  d = notnil(d)
  return merge(&d, rest(e))
}
