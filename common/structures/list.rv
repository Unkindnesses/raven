export { List, length, set, append, pop, empty?, map, collect }

bundle List(xs...)

fn list(xs...) { List(xs...) }

fn length(xs: List) {
  nparts(xs)
}

fn (xs: List)[i] {
  part(xs, i)
}

fn set(&xs: List, x, i: Int64) {
  xs = tag"common.core.set"(xs, i, x)
}

fn empty?(xs: List) {
  length(xs) == 0
}

fn append(&xs: List, x) {
  xs = [xs..., x]
  return xs
}

fn pop(&xs: List) {
  last = xs[length(xs)]
  ys = []
  for i = range(1, length(xs)-1) { append(&ys, xs[i]) }
  xs = ys
  return last
}

fn iterator(xs: List) { IndexIterator(xs) }

fn rest(xs: List) {
  if empty?(xs) { abort("List is empty")  }
  result = []
  for i = range(2, length(xs)) {
    append(&result, xs[i])
  }
  return result
}

fn show(x: List) {
  print("[")
  for i = range(1, nparts(x)) {
    if i != 1 {
      print(", ")
    }
    show(x[i])
    i = i + 1
  }
  print("]")
}

fn map(f, xs) {
  ys = []
  for x = xs {
    append(&ys, f(x))
  }
  return ys
}

fn collect(xs) { map(identity, xs) }

fn js(xs: List) {
  ys = js().Array.of()
  for x = xs { ys.push(x) }
  return ys
}
