bundle Pattern {
  Hole()
  Literal(x)
  Trait(T)
  Pack(xs...)
  Bind(name)
  Constructor(name, args...)
  And(p, q)
}

fn match(val, pack(`Hole`)) {
  return simpledict()
}

fn match(val, pack(`Literal`, pat)) {
  if (pat == val) {
    return simpledict()
  } else {
    return
  }
}

fn match(val, pack(`Trait`, pat)) {
  if isa(val, pat) {
    return simpledict()
  } else {
    return
  }
}

fn match(val, pack(`Bind`, name)) {
  bs = simpledict()
  setkey(&bs, name, val)
  return bs
}

fn match(xs, p: Pack) {
  if not(eq(nparts(xs), sub(nparts(p), 1))) { return nil }
  bs = simpledict()
  i = 0
  while lt(i, nparts(p)) {
    if not(isnil(bs)) {
      m = match(part(xs, i), part(p, add(i, 1)))
      if isnil(m) {
        bs = nil
      } else {
        bs = merge(notnil(bs), notnil(m))
      }
    } else {
      bs = nil #Â type inference hack
    }
    i = add(i, 1)
  }
  return bs
}

fn match(val, pack(`Constructor`, name, args...)) {
  match(val, constructorPattern(name, args...))
}

fn match(val, pack(`And`, p, q)) {
  bs = match(val, p)
  isnil(bs) && return
  cs = match(val, q)
  isnil(cs) && return
  merge(notnil(bs), notnil(cs))
}

fn ismatch(val, pat) {
  not(isnil(match(val, pat)))
}
